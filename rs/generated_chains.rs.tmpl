// Code generated by go generate ./rs please DO NOT EDIT

use std::{
    fmt::{Display, Formatter, Result as FmtResult},
    str::FromStr,
};
use thiserror::Error;

#[derive(Error, Debug)]
pub enum Error {
    #[error("unknown chain name: {0}")]
    UnknownChain(String),
}

#[derive(
    Debug, Hash, PartialEq, Eq, Clone, Copy, serde::Serialize, serde::Deserialize, PartialOrd, Ord,
)]
#[repr(u64)]
pub enum ChainName {
{{- range .}}
    {{ .VarName }} = {{ .EvmChainID }},
{{- end}}
}

impl ChainName {
    pub fn chain_id(self) -> u64 {
        self as u64
    }

    pub fn from_chain_id(chain_id: u64) -> Option<Self> {
        match chain_id {
        {{- range .}}
            {{ .EvmChainID }} => Some(Self::{{ .VarName }}),
        {{- end}}
            _ => None,
        } 
    }

    pub fn from_chain_selector(chain_selector: u64) -> Option<Self> {
        match chain_selector {
        {{- range .}}
            {{ .Selector }} => Some(Self::{{ .VarName }}),
        {{- end}}
            _ => None,
        } 
    }
}

impl FromStr for ChainName {
    type Err = Error;
    
    fn from_str(input: &str) -> Result<Self, Self::Err> {
        match input {
		{{- range .}}
			"{{ .Name }}" => Ok(Self::{{ .VarName }}),
		{{- end}}
            _ => Err(Error::UnknownChain(input.to_string())),
        }
    }
}

impl Display for ChainName {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        write!(
            f,
            "{}",
            match self {
			{{- range .}}
				Self::{{ .VarName }} => "{{ .Name }}",
			{{- end}}
            }
        )
    }
}

pub fn chain_selector(chain: ChainName) -> u64 {
    match chain {
    {{- range .}}
        ChainName::{{ .VarName }} => {{ .Selector }},
    {{- end}}
    }
}